{"ast":null,"code":"import _toConsumableArray from \"/home/hunter/github/backupbox/BoxProject/drone-parts-planner/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/hunter/github/backupbox/BoxProject/drone-parts-planner/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/hunter/github/backupbox/BoxProject/drone-parts-planner/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nvar _vector4 = /*@__PURE__*/new Vector4();\n\nvar _positionVector = /*@__PURE__*/new Vector3();\n\nvar _normalVector = /*@__PURE__*/new Vector3();\n\nvar _tangentVector = /*@__PURE__*/new Vector3();\n\nvar _tangentVector4 = /*@__PURE__*/new Vector4();\n\nvar _morphVector = /*@__PURE__*/new Vector3();\n\nvar _temp = /*@__PURE__*/new Vector3();\n\nvar _skinIndex = /*@__PURE__*/new Vector4();\n\nvar _skinWeight = /*@__PURE__*/new Vector4();\n\nvar _matrix = /*@__PURE__*/new Matrix4();\n\nvar _boneMatrix = /*@__PURE__*/new Matrix4(); // Confirms that the two provided attributes are compatible\n\n\nfunction validateAttributes(attr1, attr2) {\n  if (!attr1 && !attr2) {\n    return;\n  }\n\n  var sameCount = attr1.count === attr2.count;\n  var sameNormalized = attr1.normalized === attr2.normalized;\n  var sameType = attr1.array.constructor === attr2.array.constructor;\n  var sameItemSize = attr1.itemSize === attr2.itemSize;\n\n  if (!sameCount || !sameNormalized || !sameType || !sameItemSize) {\n    throw new Error();\n  }\n} // Clones the given attribute with a new compatible buffer attribute but no data\n\n\nfunction createAttributeClone(attr) {\n  var countOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var cons = attr.array.constructor;\n  var normalized = attr.normalized;\n  var itemSize = attr.itemSize;\n  var count = countOverride === null ? attr.count : countOverride;\n  return new BufferAttribute(new cons(itemSize * count), itemSize, normalized);\n} // target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\n\n\nfunction copyAttributeContents(attr, target) {\n  var targetOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (attr.isInterleavedBufferAttribute) {\n    var itemSize = attr.itemSize;\n\n    for (var i = 0, l = attr.count; i < l; i++) {\n      var io = i + targetOffset;\n      target.setX(io, attr.getX(i));\n      if (itemSize >= 2) target.setY(io, attr.getY(i));\n      if (itemSize >= 3) target.setZ(io, attr.getZ(i));\n      if (itemSize >= 4) target.setW(io, attr.getW(i));\n    }\n  } else {\n    var array = target.array;\n    var cons = array.constructor;\n    var byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n    var temp = new cons(array.buffer, byteOffset, attr.array.length);\n    temp.set(attr.array);\n  }\n} // Adds the \"matrix\" multiplied by \"scale\" to \"target\"\n\n\nfunction addScaledMatrix(target, matrix, scale) {\n  var targetArray = target.elements;\n  var matrixArray = matrix.elements;\n\n  for (var i = 0, l = matrixArray.length; i < l; i++) {\n    targetArray[i] += matrixArray[i] * scale;\n  }\n} // A version of \"SkinnedMesh.boneTransform\" for normals\n\n\nfunction boneNormalTransform(mesh, index, target) {\n  var skeleton = mesh.skeleton;\n  var geometry = mesh.geometry;\n\n  _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n\n  _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n\n  _matrix.elements.fill(0);\n\n  for (var i = 0; i < 4; i++) {\n    var weight = _skinWeight.getComponent(i);\n\n    if (weight !== 0) {\n      var boneIndex = _skinIndex.getComponent(i);\n\n      _boneMatrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n\n      addScaledMatrix(_matrix, _boneMatrix, weight);\n    }\n  }\n\n  _matrix.multiply(mesh.bindMatrix).premultiply(mesh.bindMatrixInverse);\n\n  _vector4.set(target.x, target.y, target.z, 0.0).applyMatrix4(_matrix);\n\n  target.set(_vector4.x, _vector4.y, _vector4.z);\n  return target;\n} // Applies the morph target data to the target vector\n\n\nfunction applyMorphTarget(morphData, morphInfluences, morphTargetsRelative, i, target) {\n  _morphVector.set(0, 0, 0);\n\n  for (var j = 0, jl = morphData.length; j < jl; j++) {\n    var influence = morphInfluences[j];\n    var morphAttribute = morphData[j];\n    if (influence === 0) continue;\n\n    _temp.fromBufferAttribute(morphAttribute, i);\n\n    if (morphTargetsRelative) {\n      _morphVector.addScaledVector(_temp, influence);\n    } else {\n      _morphVector.addScaledVector(_temp.sub(target), influence);\n    }\n  }\n\n  target.add(_morphVector);\n} // Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in plac\n\n\nfunction mergeBufferGeometries(geometries) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    useGroups: false,\n    updateIndex: false\n  };\n  var targetGeometry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BufferGeometry();\n  var isIndexed = geometries[0].index !== null;\n  var useGroups = options.useGroups,\n      updateIndex = options.updateIndex;\n  var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  var attributes = {};\n  var offset = 0;\n\n  for (var i = 0; i < geometries.length; ++i) {\n    var geometry = geometries[i];\n    var attributesCount = 0; // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geometry.index !== null)) {\n      throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n    } // gather attributes, exit early if they're different\n\n\n    for (var name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    } // ensure geometries have the same number of attributes\n\n\n    if (attributesCount !== attributesUsed.size) {\n      throw new Error('StaticGeometryGenerator: Make sure all geometries have the same number of attributes.');\n    }\n\n    if (useGroups) {\n      var count = void 0;\n\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        throw new Error('StaticGeometryGenerator: The geometry must have either an index or a position attribute');\n      }\n\n      targetGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  } // merge indices\n\n\n  if (isIndexed) {\n    var forceUpateIndex = false;\n\n    if (!targetGeometry.index) {\n      var indexCount = 0;\n\n      for (var _i = 0; _i < geometries.length; ++_i) {\n        indexCount += geometries[_i].index.count;\n      }\n\n      targetGeometry.setIndex(new BufferAttribute(new Uint32Array(indexCount), 1, false));\n      forceUpateIndex = true;\n    }\n\n    if (updateIndex || forceUpateIndex) {\n      var targetIndex = targetGeometry.index;\n      var targetOffset = 0;\n      var indexOffset = 0;\n\n      for (var _i2 = 0; _i2 < geometries.length; ++_i2) {\n        var _geometry = geometries[_i2];\n        var index = _geometry.index;\n\n        for (var j = 0; j < index.count; ++j) {\n          targetIndex.setX(targetOffset, index.getX(j) + indexOffset);\n          targetOffset++;\n        }\n\n        indexOffset += _geometry.attributes.position.count;\n      }\n    }\n  } // merge attributes\n\n\n  for (var _name in attributes) {\n    var attrList = attributes[_name];\n\n    if (!(_name in targetGeometry.attributes)) {\n      var _count = 0;\n\n      for (var key in attrList) {\n        _count += attrList[key].count;\n      }\n\n      targetGeometry.setAttribute(_name, createAttributeClone(attributes[_name][0], _count));\n    }\n\n    var targetAttribute = targetGeometry.attributes[_name];\n    var _offset = 0;\n\n    for (var _key in attrList) {\n      var attr = attrList[_key];\n      copyAttributeContents(attr, targetAttribute, _offset);\n      _offset += attr.count;\n    }\n  }\n\n  return targetGeometry;\n}\n\nexport var StaticGeometryGenerator = /*#__PURE__*/function () {\n  function StaticGeometryGenerator(meshes) {\n    _classCallCheck(this, StaticGeometryGenerator);\n\n    if (!Array.isArray(meshes)) {\n      meshes = [meshes];\n    }\n\n    var finalMeshes = [];\n    meshes.forEach(function (object) {\n      object.traverse(function (c) {\n        if (c.isMesh) {\n          finalMeshes.push(c);\n        }\n      });\n    });\n    this.meshes = finalMeshes;\n    this.useGroups = true;\n    this.applyWorldTransforms = true;\n    this.attributes = ['position', 'normal', 'tangent', 'uv', 'uv2'];\n    this._intermediateGeometry = new Array(finalMeshes.length).fill().map(function () {\n      return new BufferGeometry();\n    });\n  }\n\n  _createClass(StaticGeometryGenerator, [{\n    key: \"getMaterials\",\n    value: function getMaterials() {\n      var materials = [];\n      this.meshes.forEach(function (mesh) {\n        if (Array.isArray(mesh.material)) {\n          materials.push.apply(materials, _toConsumableArray(mesh.material));\n        } else {\n          materials.push(mesh.material);\n        }\n      });\n      return materials;\n    }\n  }, {\n    key: \"generate\",\n    value: function generate() {\n      var targetGeometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n      var meshes = this.meshes,\n          useGroups = this.useGroups,\n          _intermediateGeometry = this._intermediateGeometry;\n\n      for (var i = 0, l = meshes.length; i < l; i++) {\n        var mesh = meshes[i];\n        var geom = _intermediateGeometry[i];\n\n        this._convertToStaticGeometry(mesh, geom);\n      }\n\n      mergeBufferGeometries(_intermediateGeometry, {\n        useGroups: useGroups\n      }, targetGeometry);\n\n      for (var key in targetGeometry.attributes) {\n        targetGeometry.attributes[key].needsUpdate = true;\n      }\n\n      return targetGeometry;\n    }\n  }, {\n    key: \"_convertToStaticGeometry\",\n    value: function _convertToStaticGeometry(mesh) {\n      var targetGeometry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new BufferGeometry();\n      var geometry = mesh.geometry;\n      var applyWorldTransforms = this.applyWorldTransforms;\n      var includeNormal = this.attributes.includes('normal');\n      var includeTangent = this.attributes.includes('tangent');\n      var attributes = geometry.attributes;\n      var targetAttributes = targetGeometry.attributes; // initialize the attributes if they don't exist\n\n      if (!targetGeometry.index) {\n        targetGeometry.index = geometry.index;\n      }\n\n      if (!targetAttributes.position) {\n        targetGeometry.setAttribute('position', createAttributeClone(attributes.position));\n      }\n\n      if (includeNormal && !targetAttributes.normal && attributes.normal) {\n        targetGeometry.setAttribute('normal', createAttributeClone(attributes.normal));\n      }\n\n      if (includeTangent && !targetAttributes.tangent && attributes.tangent) {\n        targetGeometry.setAttribute('tangent', createAttributeClone(attributes.tangent));\n      } // ensure the attributes are consistent\n\n\n      validateAttributes(geometry.index, targetGeometry.index);\n      validateAttributes(attributes.position, targetAttributes.position);\n\n      if (includeNormal) {\n        validateAttributes(attributes.normal, targetAttributes.normal);\n      }\n\n      if (includeTangent) {\n        validateAttributes(attributes.tangent, targetAttributes.tangent);\n      } // generate transformed vertex attribute data\n\n\n      var position = attributes.position;\n      var normal = includeNormal ? attributes.normal : null;\n      var tangent = includeTangent ? attributes.tangent : null;\n      var morphPosition = geometry.morphAttributes.position;\n      var morphNormal = geometry.morphAttributes.normal;\n      var morphTangent = geometry.morphAttributes.tangent;\n      var morphTargetsRelative = geometry.morphTargetsRelative;\n      var morphInfluences = mesh.morphTargetInfluences;\n      var normalMatrix = new Matrix3();\n      normalMatrix.getNormalMatrix(mesh.matrixWorld);\n\n      for (var i = 0, l = attributes.position.count; i < l; i++) {\n        _positionVector.fromBufferAttribute(position, i);\n\n        if (normal) {\n          _normalVector.fromBufferAttribute(normal, i);\n        }\n\n        if (tangent) {\n          _tangentVector4.fromBufferAttribute(tangent, i);\n\n          _tangentVector.fromBufferAttribute(tangent, i);\n        } // apply morph target transform\n\n\n        if (morphInfluences) {\n          if (morphPosition) {\n            applyMorphTarget(morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector);\n          }\n\n          if (morphNormal) {\n            applyMorphTarget(morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector);\n          }\n\n          if (morphTangent) {\n            applyMorphTarget(morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector);\n          }\n        } // apply bone transform\n\n\n        if (mesh.isSkinnedMesh) {\n          mesh.boneTransform(i, _positionVector);\n\n          if (normal) {\n            boneNormalTransform(mesh, i, _normalVector);\n          }\n\n          if (tangent) {\n            boneNormalTransform(mesh, i, _tangentVector);\n          }\n        } // update the vectors of the attributes\n\n\n        if (applyWorldTransforms) {\n          _positionVector.applyMatrix4(mesh.matrixWorld);\n        }\n\n        targetAttributes.position.setXYZ(i, _positionVector.x, _positionVector.y, _positionVector.z);\n\n        if (normal) {\n          if (applyWorldTransforms) {\n            _normalVector.applyNormalMatrix(normalMatrix);\n          }\n\n          targetAttributes.normal.setXYZ(i, _normalVector.x, _normalVector.y, _normalVector.z);\n        }\n\n        if (tangent) {\n          if (applyWorldTransforms) {\n            _tangentVector.transformDirection(mesh.matrixWorld);\n          }\n\n          targetAttributes.tangent.setXYZW(i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w);\n        }\n      } // copy other attributes over\n\n\n      for (var _i3 in this.attributes) {\n        var key = this.attributes[_i3];\n\n        if (key === 'position' || key === 'tangent' || key === 'normal' || !(key in attributes)) {\n          continue;\n        }\n\n        if (!targetAttributes[key]) {\n          targetGeometry.setAttribute(key, createAttributeClone(attributes[key]));\n        }\n\n        validateAttributes(attributes[key], targetAttributes[key]);\n        copyAttributeContents(attributes[key], targetAttributes[key]);\n      }\n\n      return targetGeometry;\n    }\n  }]);\n\n  return StaticGeometryGenerator;\n}();","map":{"version":3,"sources":["/home/hunter/github/backupbox/BoxProject/drone-parts-planner/node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js"],"names":["BufferAttribute","BufferGeometry","Vector3","Vector4","Matrix4","Matrix3","_vector4","_positionVector","_normalVector","_tangentVector","_tangentVector4","_morphVector","_temp","_skinIndex","_skinWeight","_matrix","_boneMatrix","validateAttributes","attr1","attr2","sameCount","count","sameNormalized","normalized","sameType","array","constructor","sameItemSize","itemSize","Error","createAttributeClone","attr","countOverride","cons","copyAttributeContents","target","targetOffset","isInterleavedBufferAttribute","i","l","io","setX","getX","setY","getY","setZ","getZ","setW","getW","byteOffset","BYTES_PER_ELEMENT","temp","buffer","length","set","addScaledMatrix","matrix","scale","targetArray","elements","matrixArray","boneNormalTransform","mesh","index","skeleton","geometry","fromBufferAttribute","attributes","skinIndex","skinWeight","fill","weight","getComponent","boneIndex","multiplyMatrices","bones","matrixWorld","boneInverses","multiply","bindMatrix","premultiply","bindMatrixInverse","x","y","z","applyMatrix4","applyMorphTarget","morphData","morphInfluences","morphTargetsRelative","j","jl","influence","morphAttribute","addScaledVector","sub","add","mergeBufferGeometries","geometries","options","useGroups","updateIndex","targetGeometry","isIndexed","attributesUsed","Set","Object","keys","offset","attributesCount","name","has","undefined","push","size","position","addGroup","forceUpateIndex","indexCount","setIndex","Uint32Array","targetIndex","indexOffset","attrList","key","setAttribute","targetAttribute","StaticGeometryGenerator","meshes","Array","isArray","finalMeshes","forEach","object","traverse","c","isMesh","applyWorldTransforms","_intermediateGeometry","map","materials","material","geom","_convertToStaticGeometry","needsUpdate","includeNormal","includes","includeTangent","targetAttributes","normal","tangent","morphPosition","morphAttributes","morphNormal","morphTangent","morphTargetInfluences","normalMatrix","getNormalMatrix","isSkinnedMesh","boneTransform","setXYZ","applyNormalMatrix","transformDirection","setXYZW","w"],"mappings":"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","sourcesContent":["import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\r\n\r\nconst _vector4 = /*@__PURE__*/ new Vector4();\r\nconst _positionVector = /*@__PURE__*/ new Vector3();\r\nconst _normalVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\r\n\r\nconst _morphVector = /*@__PURE__*/ new Vector3();\r\nconst _temp = /*@__PURE__*/ new Vector3();\r\n\r\nconst _skinIndex = /*@__PURE__*/ new Vector4();\r\nconst _skinWeight = /*@__PURE__*/ new Vector4();\r\nconst _matrix = /*@__PURE__*/ new Matrix4();\r\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\r\n\r\n// Confirms that the two provided attributes are compatible\r\nfunction validateAttributes( attr1, attr2 ) {\r\n\r\n\tif ( ! attr1 && ! attr2 ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tconst sameCount = attr1.count === attr2.count;\r\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\r\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\r\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\r\n\r\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Clones the given attribute with a new compatible buffer attribute but no data\r\nfunction createAttributeClone( attr, countOverride = null ) {\r\n\r\n\tconst cons = attr.array.constructor;\r\n\tconst normalized = attr.normalized;\r\n\tconst itemSize = attr.itemSize;\r\n\tconst count = countOverride === null ? attr.count : countOverride;\r\n\r\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\r\n\r\n}\r\n\r\n// target offset is the number of elements in the target buffer stride to skip before copying the\r\n// attributes contents in to.\r\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\r\n\r\n\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\r\n\r\n\t\t\tconst io = i + targetOffset;\r\n\t\t\ttarget.setX( io, attr.getX( i ) );\r\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\r\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\r\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconst array = target.array;\r\n\t\tconst cons = array.constructor;\r\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\r\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\r\n\t\ttemp.set( attr.array );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\r\nfunction addScaledMatrix( target, matrix, scale ) {\r\n\r\n\tconst targetArray = target.elements;\r\n\tconst matrixArray = matrix.elements;\r\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\r\n\r\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// A version of \"SkinnedMesh.boneTransform\" for normals\r\nfunction boneNormalTransform( mesh, index, target ) {\r\n\r\n\tconst skeleton = mesh.skeleton;\r\n\tconst geometry = mesh.geometry;\r\n\r\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\r\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\r\n\r\n\t_matrix.elements.fill( 0 );\r\n\r\n\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\tconst weight = _skinWeight.getComponent( i );\r\n\r\n\t\tif ( weight !== 0 ) {\r\n\r\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\r\n\t\t\t_boneMatrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\r\n\r\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\r\n\t_vector4.set( target.x, target.y, target.z, 0.0 ).applyMatrix4( _matrix );\r\n\ttarget.set( _vector4.x, _vector4.y, _vector4.z );\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\n// Applies the morph target data to the target vector\r\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\r\n\r\n\t_morphVector.set( 0, 0, 0 );\r\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\r\n\r\n\t\tconst influence = morphInfluences[ j ];\r\n\t\tconst morphAttribute = morphData[ j ];\r\n\r\n\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\r\n\r\n\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp, influence );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttarget.add( _morphVector );\r\n\r\n}\r\n\r\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in plac\r\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false }, targetGeometry = new BufferGeometry() ) {\r\n\r\n\tconst isIndexed = geometries[ 0 ].index !== null;\r\n\tconst { useGroups, updateIndex } = options;\r\n\r\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\r\n\tconst attributes = {};\r\n\r\n\tlet offset = 0;\r\n\r\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\tconst geometry = geometries[ i ];\r\n\t\tlet attributesCount = 0;\r\n\r\n\t\t// ensure that all geometries are indexed, or none\r\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t}\r\n\r\n\t\t// gather attributes, exit early if they're different\r\n\t\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\t\tif ( ! attributesUsed.has( name ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes[ name ] === undefined ) {\r\n\r\n\t\t\t\tattributes[ name ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\r\n\t\t\tattributesCount ++;\r\n\r\n\t\t}\r\n\r\n\t\t// ensure geometries have the same number of attributes\r\n\t\tif ( attributesCount !== attributesUsed.size ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( useGroups ) {\r\n\r\n\t\t\tlet count;\r\n\t\t\tif ( isIndexed ) {\r\n\r\n\t\t\t\tcount = geometry.index.count;\r\n\r\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\r\n\r\n\t\t\t\tcount = geometry.attributes.position.count;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.addGroup( offset, count, i );\r\n\t\t\toffset += count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// merge indices\r\n\tif ( isIndexed ) {\r\n\r\n\t\tlet forceUpateIndex = false;\r\n\t\tif ( ! targetGeometry.index ) {\r\n\r\n\t\t\tlet indexCount = 0;\r\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\t\tindexCount += geometries[ i ].index.count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\r\n\t\t\tforceUpateIndex = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateIndex || forceUpateIndex ) {\r\n\r\n\t\t\tconst targetIndex = targetGeometry.index;\r\n\t\t\tlet targetOffset = 0;\r\n\t\t\tlet indexOffset = 0;\r\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\t\tconst geometry = geometries[ i ];\r\n\t\t\t\tconst index = geometry.index;\r\n\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\r\n\r\n\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\r\n\t\t\t\t\ttargetOffset ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindexOffset += geometry.attributes.position.count;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// merge attributes\r\n\tfor ( const name in attributes ) {\r\n\r\n\t\tconst attrList = attributes[ name ];\r\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\r\n\r\n\t\t\tlet count = 0;\r\n\t\t\tfor ( const key in attrList ) {\r\n\r\n\t\t\t\tcount += attrList[ key ].count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\r\n\t\tlet offset = 0;\r\n\t\tfor ( const key in attrList ) {\r\n\r\n\t\t\tconst attr = attrList[ key ];\r\n\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\r\n\t\t\toffset += attr.count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn targetGeometry;\r\n\r\n}\r\n\r\nexport class StaticGeometryGenerator {\r\n\r\n\tconstructor( meshes ) {\r\n\r\n\t\tif ( ! Array.isArray( meshes ) ) {\r\n\r\n\t\t\tmeshes = [ meshes ];\r\n\r\n\t\t}\r\n\r\n\t\tconst finalMeshes = [];\r\n\t\tmeshes.forEach( object => {\r\n\r\n\t\t\tobject.traverse( c => {\r\n\r\n\t\t\t\tif ( c.isMesh ) {\r\n\r\n\t\t\t\t\tfinalMeshes.push( c );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.meshes = finalMeshes;\r\n\t\tthis.useGroups = true;\r\n\t\tthis.applyWorldTransforms = true;\r\n\t\tthis.attributes = [ 'position', 'normal', 'tangent', 'uv', 'uv2' ];\r\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\r\n\r\n\t}\r\n\r\n\tgetMaterials() {\r\n\r\n\t\tconst materials = [];\r\n\t\tthis.meshes.forEach( mesh => {\r\n\r\n\t\t\tif ( Array.isArray( mesh.material ) ) {\r\n\r\n\t\t\t\tmaterials.push( ...mesh.material );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterials.push( mesh.material );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\t\treturn materials;\r\n\r\n\t}\r\n\r\n\tgenerate( targetGeometry = new BufferGeometry() ) {\r\n\r\n\t\tconst { meshes, useGroups, _intermediateGeometry } = this;\r\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst mesh = meshes[ i ];\r\n\t\t\tconst geom = _intermediateGeometry[ i ];\r\n\t\t\tthis._convertToStaticGeometry( mesh, geom );\r\n\r\n\t\t}\r\n\r\n\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups }, targetGeometry );\r\n\t\tfor ( const key in targetGeometry.attributes ) {\r\n\r\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\treturn targetGeometry;\r\n\r\n\t}\r\n\r\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\r\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\r\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\r\n\t\tconst attributes = geometry.attributes;\r\n\t\tconst targetAttributes = targetGeometry.attributes;\r\n\r\n\t\t// initialize the attributes if they don't exist\r\n\t\tif ( ! targetGeometry.index ) {\r\n\r\n\t\t\ttargetGeometry.index = geometry.index;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! targetAttributes.position ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\r\n\r\n\t\t}\r\n\r\n\t\t// ensure the attributes are consistent\r\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\r\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\r\n\r\n\t\tif ( includeNormal ) {\r\n\r\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeTangent ) {\r\n\r\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\r\n\r\n\t\t}\r\n\r\n\t\t// generate transformed vertex attribute data\r\n\t\tconst position = attributes.position;\r\n\t\tconst normal = includeNormal ? attributes.normal : null;\r\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\r\n\t\tconst morphPosition = geometry.morphAttributes.position;\r\n\t\tconst morphNormal = geometry.morphAttributes.normal;\r\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\r\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\r\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\r\n\t\tconst normalMatrix = new Matrix3();\r\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\r\n\r\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\r\n\r\n\t\t\t_positionVector.fromBufferAttribute( position, i );\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\r\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// apply morph target transform\r\n\t\t\tif ( morphInfluences ) {\r\n\r\n\t\t\t\tif ( morphPosition ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( morphNormal ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( morphTangent ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// apply bone transform\r\n\t\t\tif ( mesh.isSkinnedMesh ) {\r\n\r\n\t\t\t\tmesh.boneTransform( i, _positionVector );\r\n\t\t\t\tif ( normal ) {\r\n\r\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the vectors of the attributes\r\n\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\r\n\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// copy other attributes over\r\n\t\tfor ( const i in this.attributes ) {\r\n\r\n\t\t\tconst key = this.attributes[ i ];\r\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! targetAttributes[ key ] ) {\r\n\r\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\r\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn targetGeometry;\r\n\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}